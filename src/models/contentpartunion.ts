/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type FileT = {
  /**
   * The base64 encoded file data, used when passing the file to the model as a string.
   */
  fileData?: string | undefined;
  /**
   * The ID of an uploaded file to use as input.
   */
  fileId?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  fileName?: string | undefined;
};

/**
 * File content part.
 */
export type ContentPart4 = {
  file: FileT;
  /**
   * The type of the content part. Always file.
   */
  type: string;
};

export type InputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports wav and mp3.
   */
  format: string;
};

/**
 * Audio content part.
 */
export type ContentPart3 = {
  inputAudio: InputAudio;
  /**
   * The type of the content part. Always input_audio.
   */
  type: string;
};

export type ImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded image data.
   */
  url: string;
  /**
   * Specifies the detail level of the image.
   */
  detail?: string | undefined;
};

/**
 * Image content part.
 */
export type ContentPart2 = {
  imageUrl: ImageUrl;
  type: string;
};

/**
 * Text content part.
 */
export type ContentPart1 = {
  text: string;
  type: string;
};

export type ContentPartUnion =
  | ContentPart1
  | ContentPart2
  | ContentPart3
  | ContentPart4;

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    file_data: z.string().optional(),
    file_id: z.string().optional(),
    file_name: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
      "file_id": "fileId",
      "file_name": "fileName",
    });
  });

/** @internal */
export type FileT$Outbound = {
  file_data?: string | undefined;
  file_id?: string | undefined;
  file_name?: string | undefined;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileData: z.string().optional(),
  fileId: z.string().optional(),
  fileName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
    fileId: "file_id",
    fileName: "file_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FileT$ {
  /** @deprecated use `FileT$inboundSchema` instead. */
  export const inboundSchema = FileT$inboundSchema;
  /** @deprecated use `FileT$outboundSchema` instead. */
  export const outboundSchema = FileT$outboundSchema;
  /** @deprecated use `FileT$Outbound` instead. */
  export type Outbound = FileT$Outbound;
}

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const ContentPart4$inboundSchema: z.ZodType<
  ContentPart4,
  z.ZodTypeDef,
  unknown
> = z.object({
  file: z.lazy(() => FileT$inboundSchema),
  type: z.string(),
});

/** @internal */
export type ContentPart4$Outbound = {
  file: FileT$Outbound;
  type: string;
};

/** @internal */
export const ContentPart4$outboundSchema: z.ZodType<
  ContentPart4$Outbound,
  z.ZodTypeDef,
  ContentPart4
> = z.object({
  file: z.lazy(() => FileT$outboundSchema),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentPart4$ {
  /** @deprecated use `ContentPart4$inboundSchema` instead. */
  export const inboundSchema = ContentPart4$inboundSchema;
  /** @deprecated use `ContentPart4$outboundSchema` instead. */
  export const outboundSchema = ContentPart4$outboundSchema;
  /** @deprecated use `ContentPart4$Outbound` instead. */
  export type Outbound = ContentPart4$Outbound;
}

export function contentPart4ToJSON(contentPart4: ContentPart4): string {
  return JSON.stringify(ContentPart4$outboundSchema.parse(contentPart4));
}

export function contentPart4FromJSON(
  jsonString: string,
): SafeParseResult<ContentPart4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentPart4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentPart4' from JSON`,
  );
}

/** @internal */
export const InputAudio$inboundSchema: z.ZodType<
  InputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: z.string(),
});

/** @internal */
export type InputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const InputAudio$outboundSchema: z.ZodType<
  InputAudio$Outbound,
  z.ZodTypeDef,
  InputAudio
> = z.object({
  data: z.string(),
  format: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAudio$ {
  /** @deprecated use `InputAudio$inboundSchema` instead. */
  export const inboundSchema = InputAudio$inboundSchema;
  /** @deprecated use `InputAudio$outboundSchema` instead. */
  export const outboundSchema = InputAudio$outboundSchema;
  /** @deprecated use `InputAudio$Outbound` instead. */
  export type Outbound = InputAudio$Outbound;
}

export function inputAudioToJSON(inputAudio: InputAudio): string {
  return JSON.stringify(InputAudio$outboundSchema.parse(inputAudio));
}

export function inputAudioFromJSON(
  jsonString: string,
): SafeParseResult<InputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAudio' from JSON`,
  );
}

/** @internal */
export const ContentPart3$inboundSchema: z.ZodType<
  ContentPart3,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_audio: z.lazy(() => InputAudio$inboundSchema),
  type: z.string(),
}).transform((v) => {
  return remap$(v, {
    "input_audio": "inputAudio",
  });
});

/** @internal */
export type ContentPart3$Outbound = {
  input_audio: InputAudio$Outbound;
  type: string;
};

/** @internal */
export const ContentPart3$outboundSchema: z.ZodType<
  ContentPart3$Outbound,
  z.ZodTypeDef,
  ContentPart3
> = z.object({
  inputAudio: z.lazy(() => InputAudio$outboundSchema),
  type: z.string(),
}).transform((v) => {
  return remap$(v, {
    inputAudio: "input_audio",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentPart3$ {
  /** @deprecated use `ContentPart3$inboundSchema` instead. */
  export const inboundSchema = ContentPart3$inboundSchema;
  /** @deprecated use `ContentPart3$outboundSchema` instead. */
  export const outboundSchema = ContentPart3$outboundSchema;
  /** @deprecated use `ContentPart3$Outbound` instead. */
  export type Outbound = ContentPart3$Outbound;
}

export function contentPart3ToJSON(contentPart3: ContentPart3): string {
  return JSON.stringify(ContentPart3$outboundSchema.parse(contentPart3));
}

export function contentPart3FromJSON(
  jsonString: string,
): SafeParseResult<ContentPart3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentPart3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentPart3' from JSON`,
  );
}

/** @internal */
export const ImageUrl$inboundSchema: z.ZodType<
  ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageUrl$ {
  /** @deprecated use `ImageUrl$inboundSchema` instead. */
  export const inboundSchema = ImageUrl$inboundSchema;
  /** @deprecated use `ImageUrl$outboundSchema` instead. */
  export const outboundSchema = ImageUrl$outboundSchema;
  /** @deprecated use `ImageUrl$Outbound` instead. */
  export type Outbound = ImageUrl$Outbound;
}

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

export function imageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageUrl' from JSON`,
  );
}

/** @internal */
export const ContentPart2$inboundSchema: z.ZodType<
  ContentPart2,
  z.ZodTypeDef,
  unknown
> = z.object({
  image_url: z.lazy(() => ImageUrl$inboundSchema),
  type: z.string(),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

/** @internal */
export type ContentPart2$Outbound = {
  image_url: ImageUrl$Outbound;
  type: string;
};

/** @internal */
export const ContentPart2$outboundSchema: z.ZodType<
  ContentPart2$Outbound,
  z.ZodTypeDef,
  ContentPart2
> = z.object({
  imageUrl: z.lazy(() => ImageUrl$outboundSchema),
  type: z.string(),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentPart2$ {
  /** @deprecated use `ContentPart2$inboundSchema` instead. */
  export const inboundSchema = ContentPart2$inboundSchema;
  /** @deprecated use `ContentPart2$outboundSchema` instead. */
  export const outboundSchema = ContentPart2$outboundSchema;
  /** @deprecated use `ContentPart2$Outbound` instead. */
  export type Outbound = ContentPart2$Outbound;
}

export function contentPart2ToJSON(contentPart2: ContentPart2): string {
  return JSON.stringify(ContentPart2$outboundSchema.parse(contentPart2));
}

export function contentPart2FromJSON(
  jsonString: string,
): SafeParseResult<ContentPart2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentPart2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentPart2' from JSON`,
  );
}

/** @internal */
export const ContentPart1$inboundSchema: z.ZodType<
  ContentPart1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  type: z.string(),
});

/** @internal */
export type ContentPart1$Outbound = {
  text: string;
  type: string;
};

/** @internal */
export const ContentPart1$outboundSchema: z.ZodType<
  ContentPart1$Outbound,
  z.ZodTypeDef,
  ContentPart1
> = z.object({
  text: z.string(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentPart1$ {
  /** @deprecated use `ContentPart1$inboundSchema` instead. */
  export const inboundSchema = ContentPart1$inboundSchema;
  /** @deprecated use `ContentPart1$outboundSchema` instead. */
  export const outboundSchema = ContentPart1$outboundSchema;
  /** @deprecated use `ContentPart1$Outbound` instead. */
  export type Outbound = ContentPart1$Outbound;
}

export function contentPart1ToJSON(contentPart1: ContentPart1): string {
  return JSON.stringify(ContentPart1$outboundSchema.parse(contentPart1));
}

export function contentPart1FromJSON(
  jsonString: string,
): SafeParseResult<ContentPart1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentPart1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentPart1' from JSON`,
  );
}

/** @internal */
export const ContentPartUnion$inboundSchema: z.ZodType<
  ContentPartUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ContentPart1$inboundSchema),
  z.lazy(() => ContentPart2$inboundSchema),
  z.lazy(() => ContentPart3$inboundSchema),
  z.lazy(() => ContentPart4$inboundSchema),
]);

/** @internal */
export type ContentPartUnion$Outbound =
  | ContentPart1$Outbound
  | ContentPart2$Outbound
  | ContentPart3$Outbound
  | ContentPart4$Outbound;

/** @internal */
export const ContentPartUnion$outboundSchema: z.ZodType<
  ContentPartUnion$Outbound,
  z.ZodTypeDef,
  ContentPartUnion
> = z.union([
  z.lazy(() => ContentPart1$outboundSchema),
  z.lazy(() => ContentPart2$outboundSchema),
  z.lazy(() => ContentPart3$outboundSchema),
  z.lazy(() => ContentPart4$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentPartUnion$ {
  /** @deprecated use `ContentPartUnion$inboundSchema` instead. */
  export const inboundSchema = ContentPartUnion$inboundSchema;
  /** @deprecated use `ContentPartUnion$outboundSchema` instead. */
  export const outboundSchema = ContentPartUnion$outboundSchema;
  /** @deprecated use `ContentPartUnion$Outbound` instead. */
  export type Outbound = ContentPartUnion$Outbound;
}

export function contentPartUnionToJSON(
  contentPartUnion: ContentPartUnion,
): string {
  return JSON.stringify(
    ContentPartUnion$outboundSchema.parse(contentPartUnion),
  );
}

export function contentPartUnionFromJSON(
  jsonString: string,
): SafeParseResult<ContentPartUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentPartUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentPartUnion' from JSON`,
  );
}
