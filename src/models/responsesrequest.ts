/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import {
  InputItemUnion,
  InputItemUnion$Outbound,
  InputItemUnion$outboundSchema,
} from "./inputitemunion.js";

export type ResponsesRequestConversation = string | any;

export type ResponsesRequestInput = string | Array<InputItemUnion>;

export type ResponsesRequestToolChoice = string | any;

export type ResponsesRequest = {
  background?: boolean | null | undefined;
  conversation?: string | any | null | undefined;
  include?: Array<any> | null | undefined;
  input?: string | Array<InputItemUnion> | null | undefined;
  instructions?: string | null | undefined;
  maxOutputTokens?: number | null | undefined;
  maxToolCalls?: number | null | undefined;
  metadata?: any | undefined;
  model?: string | null | undefined;
  parallelToolCalls?: boolean | null | undefined;
  previousResponseId?: string | null | undefined;
  prompt?: any | undefined;
  promptCacheKey?: string | null | undefined;
  reasoning?: any | undefined;
  safetyIdentifier?: string | null | undefined;
  serviceTier?: string | null | undefined;
  store?: boolean | null | undefined;
  /**
   * If set, partial message deltas and streaming events will be sent. For regular HTTP responses, this must be false.
   */
  stream?: boolean | undefined;
  streamOptions?: any | undefined;
  temperature?: number | null | undefined;
  text?: any | undefined;
  toolChoice?: string | any | null | undefined;
  tools?: Array<any> | null | undefined;
  topLogprobs?: number | null | undefined;
  topP?: number | null | undefined;
  truncation?: string | null | undefined;
};

/** @internal */
export type ResponsesRequestConversation$Outbound = string | any;

/** @internal */
export const ResponsesRequestConversation$outboundSchema: z.ZodType<
  ResponsesRequestConversation$Outbound,
  z.ZodTypeDef,
  ResponsesRequestConversation
> = z.union([z.string(), z.any()]);

export function responsesRequestConversationToJSON(
  responsesRequestConversation: ResponsesRequestConversation,
): string {
  return JSON.stringify(
    ResponsesRequestConversation$outboundSchema.parse(
      responsesRequestConversation,
    ),
  );
}

/** @internal */
export type ResponsesRequestInput$Outbound =
  | string
  | Array<InputItemUnion$Outbound>;

/** @internal */
export const ResponsesRequestInput$outboundSchema: z.ZodType<
  ResponsesRequestInput$Outbound,
  z.ZodTypeDef,
  ResponsesRequestInput
> = z.union([z.string(), z.array(InputItemUnion$outboundSchema)]);

export function responsesRequestInputToJSON(
  responsesRequestInput: ResponsesRequestInput,
): string {
  return JSON.stringify(
    ResponsesRequestInput$outboundSchema.parse(responsesRequestInput),
  );
}

/** @internal */
export type ResponsesRequestToolChoice$Outbound = string | any;

/** @internal */
export const ResponsesRequestToolChoice$outboundSchema: z.ZodType<
  ResponsesRequestToolChoice$Outbound,
  z.ZodTypeDef,
  ResponsesRequestToolChoice
> = z.union([z.string(), z.any()]);

export function responsesRequestToolChoiceToJSON(
  responsesRequestToolChoice: ResponsesRequestToolChoice,
): string {
  return JSON.stringify(
    ResponsesRequestToolChoice$outboundSchema.parse(responsesRequestToolChoice),
  );
}

/** @internal */
export type ResponsesRequest$Outbound = {
  background?: boolean | null | undefined;
  conversation?: string | any | null | undefined;
  include?: Array<any> | null | undefined;
  input?: string | Array<InputItemUnion$Outbound> | null | undefined;
  instructions?: string | null | undefined;
  max_output_tokens?: number | null | undefined;
  max_tool_calls?: number | null | undefined;
  metadata?: any | undefined;
  model?: string | null | undefined;
  parallel_tool_calls?: boolean | null | undefined;
  previous_response_id?: string | null | undefined;
  prompt?: any | undefined;
  prompt_cache_key?: string | null | undefined;
  reasoning?: any | undefined;
  safety_identifier?: string | null | undefined;
  service_tier?: string | null | undefined;
  store?: boolean | null | undefined;
  stream: boolean;
  stream_options?: any | undefined;
  temperature?: number | null | undefined;
  text?: any | undefined;
  tool_choice?: string | any | null | undefined;
  tools?: Array<any> | null | undefined;
  top_logprobs?: number | null | undefined;
  top_p?: number | null | undefined;
  truncation?: string | null | undefined;
};

/** @internal */
export const ResponsesRequest$outboundSchema: z.ZodType<
  ResponsesRequest$Outbound,
  z.ZodTypeDef,
  ResponsesRequest
> = z.object({
  background: z.nullable(z.boolean()).optional(),
  conversation: z.nullable(z.union([z.string(), z.any()])).optional(),
  include: z.nullable(z.array(z.any())).optional(),
  input: z.nullable(
    z.union([z.string(), z.array(InputItemUnion$outboundSchema)]),
  ).optional(),
  instructions: z.nullable(z.string()).optional(),
  maxOutputTokens: z.nullable(z.number().int()).optional(),
  maxToolCalls: z.nullable(z.number().int()).optional(),
  metadata: z.any().optional(),
  model: z.nullable(z.string()).optional(),
  parallelToolCalls: z.nullable(z.boolean()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  prompt: z.any().optional(),
  promptCacheKey: z.nullable(z.string()).optional(),
  reasoning: z.any().optional(),
  safetyIdentifier: z.nullable(z.string()).optional(),
  serviceTier: z.nullable(z.string()).optional(),
  store: z.nullable(z.boolean()).optional(),
  stream: z.boolean().default(false),
  streamOptions: z.any().optional(),
  temperature: z.nullable(z.number()).optional(),
  text: z.any().optional(),
  toolChoice: z.nullable(z.union([z.string(), z.any()])).optional(),
  tools: z.nullable(z.array(z.any())).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  topP: z.nullable(z.number()).optional(),
  truncation: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    maxOutputTokens: "max_output_tokens",
    maxToolCalls: "max_tool_calls",
    parallelToolCalls: "parallel_tool_calls",
    previousResponseId: "previous_response_id",
    promptCacheKey: "prompt_cache_key",
    safetyIdentifier: "safety_identifier",
    serviceTier: "service_tier",
    streamOptions: "stream_options",
    toolChoice: "tool_choice",
    topLogprobs: "top_logprobs",
    topP: "top_p",
  });
});

export function responsesRequestToJSON(
  responsesRequest: ResponsesRequest,
): string {
  return JSON.stringify(
    ResponsesRequest$outboundSchema.parse(responsesRequest),
  );
}
