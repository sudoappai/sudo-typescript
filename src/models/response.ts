/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { ItemUnion, ItemUnion$inboundSchema } from "./itemunion.js";

/**
 * The ID of the conversation this response belongs to
 */
export type ResponseConversation = {
  id: string;
};

/**
 * Details about why the response is incomplete (if status is "incomplete")
 */
export type IncompleteDetails = {
  /**
   * The reason the response is incomplete
   */
  reason: string;
};

/**
 * Instructions provided to the model
 */
export type Instructions = string | Array<any>;

/**
 * Tool choice configuration
 */
export type ResponseToolChoice = string | any;

/**
 * Usage statistics for the API call
 */
export type ResponseUsage = {
  /**
   * Number of tokens in the input
   */
  inputTokens: number;
  /**
   * Breakdown of input token details
   */
  inputTokensDetails?: any | undefined;
  /**
   * Number of tokens in the output
   */
  outputTokens: number;
  /**
   * Breakdown of output token details
   */
  outputTokensDetails?: any | undefined;
  /**
   * Total number of tokens used
   */
  totalTokens: number;
};

export type ResponseT = {
  /**
   * Whether the response was generated in the background
   */
  background?: boolean | null | undefined;
  /**
   * The ID of the conversation this response belongs to
   */
  conversation?: ResponseConversation | null | undefined;
  /**
   * Unix timestamp (in seconds) when the response was created
   */
  createdAt: number;
  /**
   * Error information if the response failed
   */
  error?: any | undefined;
  /**
   * Unique identifier for the response
   */
  id: string;
  /**
   * Details about why the response is incomplete (if status is "incomplete")
   */
  incompleteDetails?: IncompleteDetails | null | undefined;
  /**
   * Instructions provided to the model
   */
  instructions?: string | Array<any> | null | undefined;
  /**
   * Maximum number of output tokens
   */
  maxOutputTokens?: number | null | undefined;
  /**
   * Maximum number of tool calls
   */
  maxToolCalls?: number | null | undefined;
  /**
   * Set of key-value pairs that can be attached to an object
   */
  metadata?: any | undefined;
  /**
   * The model used to generate the response
   */
  model: string;
  /**
   * The object type, always "response"
   */
  object: string;
  /**
   * The output items generated by the model
   */
  output?: Array<ItemUnion> | null | undefined;
  /**
   * Whether parallel tool calls are enabled
   */
  parallelToolCalls?: boolean | null | undefined;
  /**
   * ID of the previous response
   */
  previousResponseId?: string | null | undefined;
  /**
   * Prompt configuration
   */
  prompt?: any | undefined;
  /**
   * Prompt cache key
   */
  promptCacheKey?: string | null | undefined;
  /**
   * Reasoning configuration
   */
  reasoning?: any | undefined;
  /**
   * Safety identifier
   */
  safetyIdentifier?: string | null | undefined;
  /**
   * Service tier used
   */
  serviceTier?: string | null | undefined;
  /**
   * The status of the response (e.g., "in_progress", "completed", "failed", "cancelled", "incomplete")
   */
  status: string;
  /**
   * Temperature sampling parameter
   */
  temperature?: number | null | undefined;
  /**
   * Text configuration
   */
  text?: any | undefined;
  /**
   * Tool choice configuration
   */
  toolChoice?: string | any | null | undefined;
  /**
   * Tools available to the model
   */
  tools?: Array<any> | null | undefined;
  /**
   * Number of top log probabilities to return
   */
  topLogprobs?: number | null | undefined;
  /**
   * Top-p sampling parameter
   */
  topP?: number | null | undefined;
  /**
   * Truncation strategy
   */
  truncation?: string | null | undefined;
  /**
   * Usage statistics for the API call
   */
  usage?: ResponseUsage | null | undefined;
};

/** @internal */
export const ResponseConversation$inboundSchema: z.ZodType<
  ResponseConversation,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

export function responseConversationFromJSON(
  jsonString: string,
): SafeParseResult<ResponseConversation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseConversation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseConversation' from JSON`,
  );
}

/** @internal */
export const IncompleteDetails$inboundSchema: z.ZodType<
  IncompleteDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reason: z.string(),
});

export function incompleteDetailsFromJSON(
  jsonString: string,
): SafeParseResult<IncompleteDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncompleteDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncompleteDetails' from JSON`,
  );
}

/** @internal */
export const Instructions$inboundSchema: z.ZodType<
  Instructions,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.any())]);

export function instructionsFromJSON(
  jsonString: string,
): SafeParseResult<Instructions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Instructions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Instructions' from JSON`,
  );
}

/** @internal */
export const ResponseToolChoice$inboundSchema: z.ZodType<
  ResponseToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.any()]);

export function responseToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ResponseToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseToolChoice' from JSON`,
  );
}

/** @internal */
export const ResponseUsage$inboundSchema: z.ZodType<
  ResponseUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_tokens: z.number().int(),
  input_tokens_details: z.any().optional(),
  output_tokens: z.number().int(),
  output_tokens_details: z.any().optional(),
  total_tokens: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "input_tokens": "inputTokens",
    "input_tokens_details": "inputTokensDetails",
    "output_tokens": "outputTokens",
    "output_tokens_details": "outputTokensDetails",
    "total_tokens": "totalTokens",
  });
});

export function responseUsageFromJSON(
  jsonString: string,
): SafeParseResult<ResponseUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseUsage' from JSON`,
  );
}

/** @internal */
export const ResponseT$inboundSchema: z.ZodType<
  ResponseT,
  z.ZodTypeDef,
  unknown
> = z.object({
  background: z.nullable(z.boolean()).optional(),
  conversation: z.nullable(z.lazy(() => ResponseConversation$inboundSchema))
    .optional(),
  created_at: z.number().int(),
  error: z.any().optional(),
  id: z.string(),
  incomplete_details: z.nullable(z.lazy(() => IncompleteDetails$inboundSchema))
    .optional(),
  instructions: z.nullable(z.union([z.string(), z.array(z.any())])).optional(),
  max_output_tokens: z.nullable(z.number().int()).optional(),
  max_tool_calls: z.nullable(z.number().int()).optional(),
  metadata: z.any().optional(),
  model: z.string(),
  object: z.string(),
  output: z.nullable(z.array(ItemUnion$inboundSchema)).optional(),
  parallel_tool_calls: z.nullable(z.boolean()).optional(),
  previous_response_id: z.nullable(z.string()).optional(),
  prompt: z.any().optional(),
  prompt_cache_key: z.nullable(z.string()).optional(),
  reasoning: z.any().optional(),
  safety_identifier: z.nullable(z.string()).optional(),
  service_tier: z.nullable(z.string()).optional(),
  status: z.string(),
  temperature: z.nullable(z.number()).optional(),
  text: z.any().optional(),
  tool_choice: z.nullable(z.union([z.string(), z.any()])).optional(),
  tools: z.nullable(z.array(z.any())).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  top_p: z.nullable(z.number()).optional(),
  truncation: z.nullable(z.string()).optional(),
  usage: z.nullable(z.lazy(() => ResponseUsage$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "incomplete_details": "incompleteDetails",
    "max_output_tokens": "maxOutputTokens",
    "max_tool_calls": "maxToolCalls",
    "parallel_tool_calls": "parallelToolCalls",
    "previous_response_id": "previousResponseId",
    "prompt_cache_key": "promptCacheKey",
    "safety_identifier": "safetyIdentifier",
    "service_tier": "serviceTier",
    "tool_choice": "toolChoice",
    "top_logprobs": "topLogprobs",
    "top_p": "topP",
  });
});

export function responseFromJSON(
  jsonString: string,
): SafeParseResult<ResponseT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseT' from JSON`,
  );
}
